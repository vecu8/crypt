<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypt Tool Documentation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            font-size: 90%;
            color: #c7254e;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            overflow-x: auto;
        }
        h1, h2, h3, h4 {
            color: #333;
        }
        .command {
            margin-bottom: 30px;
        }
        ul {
            line-height: 1.6;
        }
        .details {
            margin-left: 20px;
            font-size: 90%;
            color: #555;
        }
    </style>
</head>
<body>
    <h1>Crypt Tool Documentation</h1>

    <p>The <code>crypt</code> tool is a versatile command-line application that provides various cryptographic functionalities, including key generation, XOR encryption/decryption, byte scrambling, and secure file erasure. It incorporates memory safety features to securely handle sensitive data.</p>

    <h2>Available Commands</h2>
    <p>The tool provides the following commands:</p>
    <ul>
        <li><code>keygen</code>: Generate cryptographic key files.</li>
        <li><code>xor</code>: Perform XOR encryption or decryption on files.</li>
        <li><code>scramble</code>: Randomly shuffle the bytes of a file.</li>
        <li><code>erase</code>: Securely erase files by overwriting them with random data.</li>
    </ul>

    <div class="command">
        <h2>1. <code>keygen</code> Command</h2>
        <p><strong>Purpose:</strong> Generate a key file of a specified size, either randomly or deterministically using a password.</p>
        <h3>Usage:</h3>
        <pre><code>crypt keygen &lt;size&gt; --output-file &lt;output_file&gt; --mode &lt;random|deterministic&gt; [--password &lt;password&gt;]</code></pre>
        <h3>Arguments:</h3>
        <ul>
            <li><code>&lt;size&gt;</code>: The size of the key file to generate. Examples:
                <ul>
                    <li><code>32bytes</code></li>
                    <li><code>20mb</code></li>
                    <li><code>5gb</code></li>
                </ul>
            </li>
            <li><code>--output-file &lt;output_file&gt;</code>: The path where the generated key file will be saved. This file must not already exist.</li>
            <li><code>--mode &lt;random|deterministic&gt;</code>: The mode of key generation.
                <ul>
                    <li><code>random</code>: Generates a key with random data.</li>
                    <li><code>deterministic</code>: Generates a key based on a password.</li>
                </ul>
            </li>
            <li><code>--password &lt;password&gt;</code> (optional): Required if <code>--mode</code> is set to <code>deterministic</code>. This password is used to generate the deterministic key.</li>
        </ul>
        <h3>How It Works:</h3>
        <p>In <strong>random</strong> mode, the tool uses a secure random number generator to produce a key file of the specified size.</p>
        <p>In <strong>deterministic</strong> mode, the tool derives a key from the provided password using the Argon2 key derivation function with specified parameters. The derived key is then used to seed a ChaCha20 random number generator, which produces the key data. Additionally, AES-256 in CTR mode is applied to further process the random data, enhancing security.</p>
        <h3>Memory Safety:</h3>
        <ul>
            <li>Sensitive data such as the derived key and password are securely zeroed out from memory after use using the <code>zeroize</code> crate.</li>
            <li>Buffers holding random data are also zeroed to prevent any leakage of sensitive information.</li>
        </ul>
        <h3>Examples:</h3>
        <pre><code># Generate a 32-byte random key and save it to random_key.key
crypt keygen 32bytes --output-file random_key.key --mode random

# Generate a 20 MB deterministic key with a password and save it to deterministic_key.key
crypt keygen 20mb --output-file deterministic_key.key --mode deterministic --password mypassword</code></pre>
    </div>

    <div class="command">
        <h2>2. <code>xor</code> Command</h2>
        <p><strong>Purpose:</strong> Perform XOR encryption or decryption on a file using a key file.</p>
        <h3>Usage:</h3>
        <pre><code>crypt xor &lt;input_file&gt; &lt;output_file&gt; &lt;key_file&gt;</code></pre>
        <h3>Arguments:</h3>
        <ul>
            <li><code>&lt;input_file&gt;</code>: The path to the input file you want to encrypt or decrypt.</li>
            <li><code>&lt;output_file&gt;</code>: The path where the output (encrypted or decrypted) file will be saved. This file must not already exist.</li>
            <li><code>&lt;key_file&gt;</code>: The path to the key file that will be used for the XOR operation. The key file must be at least as large as the input file.</li>
        </ul>
        <h3>How It Works:</h3>
        <p>The tool reads the input file and the key file into memory. It then performs a byte-wise XOR operation between the input data and the key data. The result is written to the output file. XOR encryption is symmetric, so performing the operation twice with the same key will return the original data.</p>
        <h3>Memory Safety:</h3>
        <ul>
            <li>After the operation, the input data, key data, and processed data are securely zeroed out from memory using the <code>zeroize</code> crate.</li>
            <li>This ensures that sensitive data does not remain in memory after the process completes.</li>
        </ul>
        <h3>Examples:</h3>
        <pre><code># Encrypt a file using a key
crypt xor mydocument.txt encrypted_output.bin mykey.key

# Decrypt a file using the same key
crypt xor encrypted_output.bin decrypted_document.txt mykey.key</code></pre>
    </div>

    <div class="command">
        <h2>3. <code>scramble</code> Command</h2>
        <p><strong>Purpose:</strong> Randomly shuffle the bytes of a file.</p>
        <h3>Usage:</h3>
        <pre><code>crypt scramble &lt;input_file&gt; [output_file] [--overwrite]</code></pre>
        <h3>Arguments:</h3>
        <ul>
            <li><code>&lt;input_file&gt;</code>: The path to the input file you want to scramble.</li>
            <li><code>output_file</code> (optional): The path where the scrambled output file will be saved. This file must not already exist.</li>
            <li><code>--overwrite</code> (optional): If specified, the input file will be overwritten with the scrambled data.</li>
        </ul>
        <h3>Notes:</h3>
        <ul>
            <li>You must specify either an <code>output_file</code> or use the <code>--overwrite</code> flag.</li>
            <li>If neither is specified, the command will display an error and exit.</li>
            <li>If both are specified, the scrambled data will be written to the <code>output_file</code>, and the input file will not be modified.</li>
        </ul>
        <h3>How It Works:</h3>
        <p>The tool reads the entire input file into memory and then randomly shuffles the order of the bytes using a secure random number generator. The shuffled data is then written to the specified output file or overwrites the original file if the <code>--overwrite</code> flag is used.</p>
        <h3>Memory Safety:</h3>
        <ul>
            <li>After the operation, the data buffer containing the file's contents is securely zeroed out using the <code>zeroize</code> crate.</li>
            <li>This prevents any residual data from remaining in memory.</li>
        </ul>
        <h3>Examples:</h3>
        <pre><code># Scramble a file and write to a new file
crypt scramble input.txt scrambled_output.txt

# Scramble a file and overwrite the original file
crypt scramble input.txt --overwrite</code></pre>
    </div>

    <div class="command">
        <h2>4. <code>erase</code> Command</h2>
        <p><strong>Purpose:</strong> Securely erase a file by overwriting it with random data.</p>
        <h3>Usage:</h3>
        <pre><code>crypt erase &lt;input_file&gt; [--passes &lt;number_of_passes&gt;]</code></pre>
        <h3>Arguments:</h3>
        <ul>
            <li><code>&lt;input_file&gt;</code>: The path to the file you want to securely erase.</li>
            <li><code>--passes &lt;number_of_passes&gt;</code> (optional): Number of times to overwrite the file. Default is 1.</li>
        </ul>
        <h3>How It Works:</h3>
        <p>The tool overwrites the file with random data, one or more times depending on the specified number of passes. Each pass involves writing random bytes to the file's entire length. This reduces the likelihood of recovering the original data using forensic methods.</p>
        <h3>Memory Safety:</h3>
        <ul>
            <li>Buffers used for holding random data are securely zeroed out after each pass using the <code>zeroize</code> crate.</li>
            <li>This ensures that no remnants of the random data remain in memory.</li>
        </ul>
        <h3>Examples:</h3>
        <pre><code># Securely erase a file with 1 pass
crypt erase sensitive_data.txt

# Securely erase a file with 3 passes
crypt erase sensitive_data.txt --passes 3</code></pre>
    </div>

    <h2>Detailed Explanations and Memory Safety</h2>
    <h3>Key Generation (<code>keygen</code>)</h3>
    <p>The key generation process involves creating cryptographic keys that can be used for encryption, decryption, or other cryptographic operations. The tool supports two modes:</p>
    <ul>
        <li><strong>Random Mode:</strong> Utilizes the operating system's cryptographically secure random number generator to produce random bytes for the key file.</li>
        <li><strong>Deterministic Mode:</strong> Derives a key from a password using the Argon2 key derivation function. This key is then used to seed a ChaCha20 random number generator, which generates the key data. Additionally, AES-256 in CTR mode is applied to enhance security.</li>
    </ul>
    <p><strong>Memory Safety Measures:</strong></p>
    <ul>
        <li>The derived key and any buffers holding random data are securely zeroed out using the <code>zeroize</code> crate after they are no longer needed.</li>
        <li>The password provided by the user is also securely handled to prevent it from lingering in memory.</li>
    </ul>

    <h3>XOR Encryption/Decryption (<code>xor</code>)</h3>
    <p>The XOR operation is a simple yet effective method for encrypting and decrypting data. It works by applying the XOR logical operation between each byte of the input data and the corresponding byte of the key data.</p>
    <p><strong>Memory Safety Measures:</strong></p>
    <ul>
        <li>The input data, key data, and processed (encrypted/decrypted) data are all loaded into memory for the operation.</li>
        <li>After the operation completes, all these buffers are securely zeroed out using the <code>zeroize</code> crate to ensure that sensitive data does not remain in memory.</li>
    </ul>

    <h3>Byte Scrambling (<code>scramble</code>)</h3>
    <p>Byte scrambling rearranges the bytes of a file in a random order. This can obfuscate the original content, making it difficult to interpret without knowledge of the original byte order.</p>
    <p><strong>Memory Safety Measures:</strong></p>
    <ul>
        <li>The entire file is read into a buffer in memory for shuffling.</li>
        <li>After writing the scrambled data to the output file or overwriting the original file, the data buffer is securely zeroed out using the <code>zeroize</code> crate.</li>
    </ul>
    <p><strong>Important Note:</strong> Byte scrambling is not a secure form of encryption. It should not be used for protecting sensitive data from unauthorized access.</p>

    <h3>Secure File Erasure (<code>erase</code>)</h3>
    <p>Secure file erasure involves overwriting the contents of a file with random data to prevent recovery of the original data.</p>
    <p><strong>Memory Safety Measures:</strong></p>
    <ul>
        <li>Buffers used for holding random data during overwriting are securely zeroed out after each pass using the <code>zeroize</code> crate.</li>
        <li>This practice ensures that no sensitive data or random data remains in memory after the operation.</li>
    </ul>
    <p><strong>Important Note:</strong> Due to the nature of modern storage devices like SSDs, which use wear leveling, data might not be completely overwritten. For highly sensitive data, consider additional measures such as physical destruction.</p>

    <h2>General Notes</h2>
    <ul>
        <li>All commands check for existing output files to prevent accidental overwriting unless explicitly specified (e.g., using the <code>--overwrite</code> flag).</li>
        <li>The tool uses secure random number generators provided by the operating system to ensure cryptographic security.</li>
        <li>Memory safety is enforced throughout the application using the <code>zeroize</code> crate to prevent sensitive data from lingering in memory.</li>
        <li>The application does not provide built-in help or version information. For detailed instructions and examples, refer to this documentation.</li>
        <li>Always make sure you have the necessary permissions to read and write the specified files.</li>
    </ul>

    <h2>Security Considerations</h2>
    <p>While the <code>crypt</code> tool incorporates several security measures, it's important to understand its limitations:</p>
    <ul>
        <li><strong>XOR Encryption:</strong> XOR encryption is not secure against modern cryptographic attacks, especially if the key is reused or predictable. It should not be used for encrypting highly sensitive data.</li>
        <li><strong>Byte Scrambling:</strong> Scrambling bytes does not securely protect data. It only obfuscates the data superficially.</li>
        <li><strong>Secure Erasure:</strong> Due to hardware-level optimizations in storage devices, secure file erasure may not guarantee that data is unrecoverable. For highly sensitive data, consider using specialized tools or methods.</li>
    </ul>
    <p>For robust security, consider using established cryptographic protocols and tools designed for secure encryption and data handling.</p>
</body>
</html>
